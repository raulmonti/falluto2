-- Ejemplo largo con todos los casos posibles de imput (o por lo menos se espera que los tenga)

FLLNAME LargeOutput

MODULE mod1 (contextv1, contextv2; synchro1, synchro2)

	VAR

		localv1: bool
		localv2: { a, e, i, o, u }
		localv3: -12..1200

	FAULT

		fault1 : 								is BIZ(localv1, localv2)
		fault2 : localv1 	=> 	localv2' = u 				is TRANSIENT
		fault3 : localv3 = contextv1 + contextv2 				is STOP(trans1, synchro1)
		fault4 : localv3 = contextv1 - contextv2 => localv1' = TRUE 		is STOP

	INIT

		localv1 = TRUE | localv1 = FALSE & localv2 = a -> localv3 < 10

	TRANS

		[trans1]: localv1 = TRUE & localv2 = u  => localv2' = a, localv3' = localv3 + 1
		[]: localv1 = FALSE & localv2 = a => localv2' = e, localv3' = localv3 + 1 
		[]: localv1 = FALSE & localv2 = e => localv2' = i, localv3' = localv3 + 1
		[]: localv1 = FALSE & localv2 = i => localv2' = o, localv3' = localv3 + 1
		[]: localv1 = FALSE & localv2 = o => localv2' = u, localv3' = localv3 + 1
		[synchro1]: => localv1' = TRUE
		[synchro2]: localv3 = 1200 => localv3' = 0

ENDMODULE

MODULE mod2(; reset1, reset2)

	VAR

		sem : bool

	FAULT

	INIT
		sem = TRUE
	TRANS
		[]:
		[reset1]: sem => sem' = FALSE
		[reset2]: !sem => sem' = TRUE
ENDMODULE

MODULE mod3 ()
ENDMODULE


INSTANCE inst1 = mod1( v1, v2, s1, s2)
INSTANCE inst2 = mod2( s1, s2)
INSTANCE inst3 = mod3()
INSTANCE inst4 = mod2( s3, s4)
INSTANCE inst5 = mod1( inst1.localv1, v2, s1, s4)



LTLSPEC G inst1.localv3 < 1201 & just(s1) -> inst5.localv3 = 0

FAIRNESS just(s1)

COMPASSION ( just(s1), just(s2))
